<style>
    ol {
        list-style: none;
        counter-reset: li;
    }
    li:before {
        counter-increment: li; 
        content: counters(li,".") ". ";
    }
</style>
<h1 id="table-of-contents">Table of contents</h1>
<ol>
<li><p><a href="#general-information">General information</a></p>
</li>
<li><p><a href="#assembler">Assembler</a></p>
<ol>
<li><p><a href="#assembler-syntaxis">Assembler syntaxis</a></p>
<ol>
<li><p><a href="#general-rules">General rules</a></p>
</li>
<li><p><a href="#list-of-allowed-instructions">List of allowed instructions</a></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="general-information">General information</h1>
<p>This project is called &quot;Processor&quot;. It includes 3 programs: <strong>Assembler</strong>, <strong>Processor</strong> and <strong>Disassembler</strong>.</p>
<p><strong>Assembler</strong> receives a .txt file with instructions on my own assembler language. The result of its work is a .bin file with these instructions translated into the binary format.</p>
<p><strong>Disassembler</strong> does exactly the opposite to what <strong>Assembler</strong> does.</p>
<p><strong>Processor</strong> receives a .bin file from <strong>Assembler</strong>. Then it process the content.</p>
<h1 id="assembler">Assembler</h1>
<h2 id="assembler-syntaxis">Assembler syntaxis</h2>
<h3 id="general-rules">General rules</h3>
<ol>
<li><p>Each insruction has to be written on a new line.</p>
</li>
<li><p>An instruction can be prefaced with a number of spaces and/or tab characters.</p>
</li>
<li><p>If an instruction has arguments, they can be separeted from the instruction and from each other by a number of spaces and/or tab characters.</p>
</li>
<li><p>Empty lines are allowed.</p>
</li>
<li><p>All characters from a semicolon (&#39;;&#39;) to the line ending charachter (&#39;\n&#39;) are interpreted as a comment and ignrored.</p>
</li>
<li><p>Label is any sequence of charachers preceding the colon. Label and the colon have to be only character on the line.</p>
</li>
</ol>
<h3 id="list-of-allowed-instructions">List of allowed instructions</h3>
<blockquote>
<p>In this section the top of the stack is reffered as <strong>T</strong> (top), an element of the stack that is first &quot;under&quot; the top is reffered as <strong>PT</strong> (pre-top).</p>
</blockquote>
<ol>
<li><p><strong>Work with stack</strong></p>
<ul>
<li><p><strong>push</strong>: pushes something in stack. There are 5 variants of <strong>push</strong>:</p>
<ul>
<li><p><code>push 123.456</code>: pushes 123.456 (generally: double number) in stack.</p>
</li>
<li><p><code>push ax</code>: pushes number from register <strong>ax</strong> (generally: ax, bx, cx or dx) in stack.</p>
</li>
<li><p><code>push [4]</code>: pushes number from RAM cell with index 4 (generally: positive integer number) in stack.</p>
</li>
<li><p><code>push [ax]</code>: pushes number from RAM cell with index from register <strong>ax</strong> (generally: ax, bx, cx or dx) in stack.</p>
</li>
<li><p><code>push [ax + 4]</code>: pushes number from RAM cell which index is 4 (generally: positive interger number) greater than a number form register 
<strong>ax</strong> (generally: ax, bx, cx or dx) in stack.</p>
</li>
</ul>
</li>
<li><p><strong>pop</strong>: pops something from stack. There are 4 variants of <strong>pop</strong>:</p>
<ul>
<li><p><code>pop</code>: pops number from stack.</p>
</li>
<li><p><code>pop ax</code>: pops number from stack and puts it in register <strong>ax</strong> (generally: ax, bx, cx or dx).</p>
</li>
<li><p><code>push [4]</code>: pops number from stack and puts it in RAM cell with index 4 (generally: positive integer number).</p>
</li>
<li><p><code>push [ax]</code>: pops number from stack and puts it in RAM cell with index from register <strong>ax</strong> (generally: ax, bx, cx or dx).</p>
</li>
<li><p><code>push [ax + 4]</code>: pops number from stack and puts it in RAM cell which index is 4 (generally: positive interger number) greater than a number form register <strong>ax</strong> (generally: ax, bx, cx or dx).</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Jumps</strong></p>
<ul>
<li><p><strong>jmp</strong> (jump): makes jump to the label which name is &quot;label_name&quot;.</p>
<p><code>jmp &quot;label_name&quot;</code></p>
<blockquote>
<p>Using any of next 6 jumps leads to popping 2 elements from stack.</p>
</blockquote>
</li>
<li><p><strong>ja</strong> (jump if above): makes jump to the label which name is &quot;label_name&quot; if <strong>PT &gt; T</strong>.</p>
<p><code>ja &quot;label_name&quot;</code></p>
</li>
<li><p><strong>jae</strong> (jump if above or equal): makes jump to the label which name is &quot;label_name&quot; if <strong>PT &gt;= T</strong>.</p>
<p><code>jae &quot;label_name&quot;</code></p>
</li>
<li><p><strong>jb</strong> (jump if below): makes jump to the label which name is &quot;label_name&quot; if <strong>PT &lt; T</strong>.</p>
<p><code>jb &quot;label_name&quot;</code></p>
</li>
<li><p><strong>jbe</strong> (jump if below): makes jump to the label which name is &quot;label_name&quot; if <strong>PT &lt;= T</strong>.</p>
<p><code>jbe &quot;label_name&quot;</code></p>
</li>
<li><p><strong>je</strong> (jump if equal): makes jump to the label which name is &quot;label_name&quot; if <strong>PT == T</strong>.</p>
<p><code>je &quot;label_name&quot;</code></p>
</li>
<li><p><strong>jne</strong> (jump if equal): makes jump to the label which name is &quot;label_name&quot; if <strong>PT != T</strong>.</p>
<p><code>jne &quot;label_name&quot;</code></p>
</li>
</ul>
</li>
<li><p><strong>Arithmetic operations</strong></p>
<ul>
<li><p><strong>sqrt</strong>: pops <strong>T</strong>, calculates quadratic root from <strong>T</strong> and pushes result in stack.</p>
<blockquote>
<p>Processing any of 4 next arithmetic operations starts with popping <strong>T</strong> and <strong>PT</strong>.</p>
</blockquote>
</li>
<li><p><strong>add</strong>: calculates <strong>PT + T</strong> and pushes result in stack.</p>
<p><code>add</code></p>
</li>
<li><p><strong>sub</strong>: calculates <strong>PT - T</strong> and pushes result in stack.</p>
<p><code>sub</code></p>
</li>
<li><p><strong>mul</strong>: calculates <strong>PT * T</strong> and pushes result in stack.</p>
<p><code>mul</code></p>
</li>
<li><p><strong>dvd</strong>: calculates <strong>PT / T</strong> and pushes result in stack. If <strong>T == 0</strong>, processing stops with error.</p>
<p><code>dvd</code></p>
</li>
</ul>
</li>
<li><p><strong>Usage of functions</strong></p>
<ul>
<li><p><strong>call</strong>: saves ip of the next command in the call stack, then makes jump to the label which name is &quot;label_name&quot;.</p>
<p><code>call &quot;label_name&quot;</code></p>
</li>
<li><p><strong>ret</strong>: pops element of the call stack than changes ip to poped value.</p>
<p><code>ret</code></p>
</li>
</ul>
</li>
<li><p><strong>Service instructions</strong></p>
<ul>
<li><p><strong>hlt</strong>: ends processing instructions.</p>
<p><code>hlt</code></p>
</li>
<li><p><strong>in</strong>: askes for a double number from stdin.</p>
<p><code>in</code></p>
</li>
<li><p><strong>out</strong>: puts a dobule number in stdout.</p>
<p><code>out</code></p>
<p>Message on the screen:</p>
<p><code>Popped number: 1.123457</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="binary-file-standard">Binary file standard</h2>
<blockquote>
<p>Each instruction can be translated in a 1, 2, 4, 5, 9 or 12 bytes (if sizeof (double) == 8). Each instruction starts with a byte encoding instruciton number.</p>
</blockquote>
<ol>
<li><p><strong>Instructions without arguments:</strong> no extra bytes.</p>
</li>
<li><p><strong>Jumps and call:</strong> 4 bytes (sizeof (int)) contain ip of a new instruction.</p>
</li>
<li><p><strong>Push and pop:</strong></p>
<blockquote>
<p><strong>1st byte:</strong> RAM is used =&gt; 1; RAM isn&#39;t used =&gt; 0.</p>
</blockquote>
<blockquote>
<p><strong>2nd byte:</strong> registers aren&#39;t used =&gt; 0; <strong>ax</strong> is used =&gt; 1; <strong>bx</strong> is used =&gt; 2; <strong>cx</strong> is used =&gt; 3; <strong>dx</strong> is used =&gt; 4;</p>
</blockquote>
<blockquote>
<p><strong>3rd byte:</strong> argument contains a number =&gt; 1; argument doesn&#39;t contain a number =&gt; 0.</p>
</blockquote>
<blockquote>
<p>If 3rd byte is 1: 8 (sizeof (double)) contain a double number.</p>
</blockquote>
<blockquote>
<p>Then it is considered that <strong>push</strong> has number 12, <strong>pop</strong> has number 13.</p>
</blockquote>
<ul>
<li><p><code>push 123.456</code>:</p>
<p>  0C 00 00 00 123.456</p>
</li>
<li><p><code>push ax</code>:</p>
<p>  0C 00 01 00</p>
</li>
<li><p><code>push [4]</code>:</p>
<p>  0C 01 00 01 4.0</p>
</li>
<li><p><code>push [bx]</code>:</p>
<p>  0C 01 02 00</p>
</li>
<li><p><code>push [ax + 4]</code>:</p>
<p>  0C 01 01 01 4.0</p>
</li>
<li><p><code>pop</code>:</p>
<p>  0D 00 00 00</p>
</li>
<li><p><code>pop ax</code>:</p>
<p>  0D 00 01 00</p>
</li>
<li><p><code>pop [4]</code>:</p>
<p>  0D 01 00 01 4.0</p>
</li>
<li><p><code>pop [bx]</code>:</p>
<p>  0D 01 02 00</p>
</li>
<li><p><code>pop [ax + 4]</code>:</p>
<p>  0D 01 01 01 4.0</p>
</li>
</ul>
</li>
<li><p><strong>Extra instructions with only one argument (can be added)</strong>: 8 (sizeof (double)) contain a double number.</p>
</li>
</ol>
